#include "U8glib.h"
#include "max6675.h"
#include <EEPROM.h>

U8GLIB_ST7920_128X64_4X u8g(13, 12, 11);
MAX6675 thermocouple(7, 5, 4);

const uint8_t rook_bitmap[] U8G_PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x0C, 0x38, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x0C, 0x38, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x0E, 0x70, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x0F, 0x80, 0x01, 0x80, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x1F, 0xC0, 0x01, 0x80, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x18, 0x60, 0x01, 0x80, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x38, 0x60, 0x01, 0x80, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x60, 0x01, 0x83, 0xE0, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x18, 0x60, 0x01, 0x87, 0xF0, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x1C, 0xE0, 0x01, 0x8E, 0x30, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x0F, 0xC0, 0x03, 0x8C, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x07, 0x00, 0x07, 0x8C, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x00, 0x0E, 0x0C, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x00, 0x1C, 0x0E, 0x30, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x00, 0x38, 0x0F, 0xF0, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x00, 0x30, 0x1D, 0xC0, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x00, 0x30, 0x38, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x0F, 0x83, 0x00, 0x30, 0xF0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x1F, 0xC3, 0x00, 0x30, 0xE0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x38, 0xE3, 0x80, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x30, 0x63, 0xC0, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x30, 0x61, 0xE0, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x30, 0x60, 0xF0, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x1D, 0xE0, 0x78, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x1F, 0xF0, 0x1C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x07, 0x38, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x1C, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x0E, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x07, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x03, 0x0C, 0x30, 0xC0, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

volatile int lastEncoded = 0;
volatile long encoderValue = 0;
int last = 0;

volatile float temperature;//measured temp
volatile float dispTemperature[10];//average for display
volatile word pottemperature;//current set temp
volatile word settemperature;//current set temp
volatile word sleeptemperature;//user set sleep temp
volatile int counter;//measure interval
volatile int count;//pwm counter
volatile int power[10];//average for display
int tempGraph[40];

long lastencoderValue = 0;

int lastMSB = 0;
int lastLSB = 0;

byte state;
unsigned long timer;
bool initt = false;
bool sleep = false;
volatile bool trained = false;
volatile int fullPower = 0;
volatile int fullPowerSet = 0;

void setup() {
  Serial.begin(115200);
  pinMode(2, INPUT);//encoder
  pinMode(A4, INPUT);//encoder
  pinMode(A5, INPUT);//encoder
  pinMode(8, INPUT);//button
  pinMode(6, OUTPUT);//red
  digitalWrite(6, HIGH);
  pinMode(9, OUTPUT);//blue
  digitalWrite(9, HIGH);
  pinMode(10, OUTPUT);//green
  digitalWrite(10, HIGH);

  pinMode(3, INPUT);//zero crossing
  pinMode(A0, OUTPUT);//power
  pinMode(A2, INPUT_PULLUP);//sleep
  digitalWrite(A0, LOW);//switch iron off

  counter = 0;
  temperature = thermocouple.readCelsius();
  settemperature = word(EEPROM.read(0), EEPROM.read(1));
  sleeptemperature = word(EEPROM.read(2), EEPROM.read(3));
  attachInterrupt(0, updateEncoder, CHANGE);
  attachInterrupt(1, zero, RISING);
  // wait for MAX chip to stabilize
  //delay(500);
  u8g.begin();
  u8g.setColorIndex(0);         // pixel on
  u8g.drawBox(0, 0, 128, 64);
  u8g.setColorIndex(1);         // pixel on
  timer = millis() + 2000;
  state = 0;

}

void loop() {

  if (digitalRead(8) && initt) {

    state++;
    encoderValue = 0;
    last = 0;
    if (state >= 3) {
      state = 1;
      EEPROM.write(0, highByte(settemperature));
      EEPROM.write(1, lowByte(settemperature));
      EEPROM.write(2, highByte(sleeptemperature));
      EEPROM.write(3, lowByte(sleeptemperature));
    }


    delay(200);
  }

  if (millis() > timer && !initt) {
    state++;
    initt = true;
    timer = millis() + 1000;
  }
  else if (millis() > timer && initt) {
    for (int i = 39; i > 0; i--) {
      tempGraph[i] = tempGraph[i - 1];
    }
    tempGraph[0] = ((dispTemperature[0] + dispTemperature[1] + dispTemperature[2] + dispTemperature[3] + dispTemperature[4] + dispTemperature[5] + dispTemperature[6] + dispTemperature[7] + dispTemperature[8] + dispTemperature[9]) / 10);
    timer = millis() + 1000;
  }

  if (!digitalRead(A2)) {
    pottemperature = sleeptemperature;
    sleep = true;
    if (((dispTemperature[0] + dispTemperature[1] + dispTemperature[2] + dispTemperature[3] + dispTemperature[4] + dispTemperature[5] + dispTemperature[6] + dispTemperature[7] + dispTemperature[8] + dispTemperature[9]) / 10) < settemperature - 30) {
      fullPower =  fullPowerSet - (((((dispTemperature[0] + dispTemperature[1] + dispTemperature[2] + dispTemperature[3] + dispTemperature[4] + dispTemperature[5] + dispTemperature[6] + dispTemperature[7] + dispTemperature[8] + dispTemperature[9]) / 10) - sleeptemperature) / (settemperature - sleeptemperature)) * fullPowerSet);
    }
    else {
      fullPower = 0;
    }
    
    Serial.println( fullPower);
  }
  else {
    pottemperature = settemperature;
    sleep = false;
  }

  switch (state) {
    case 0://start logo
      u8g.firstPage();
      do {
        u8g.drawBitmapP( 0, 0, 16, 64, rook_bitmap);
      } while ( u8g.nextPage() );

      break;
    case 1://set temp+graph
    
      settemperature += (encoderValue - last) * 2;
      last = encoderValue;
      settemperature = constrain(settemperature, sleeptemperature + 10, 400);
      u8g.firstPage();
      do {
        //graphic commands to redraw the complete screen should be placed here
        // u8g.setFont(u8g_font_unifont);
        u8g.setFont(u8g_font_helvB12);
        char buf[100];
        double dispTemp = (dispTemperature[0] + dispTemperature[1] + dispTemperature[2] + dispTemperature[3] + dispTemperature[4] + dispTemperature[5] + dispTemperature[6] + dispTemperature[7] + dispTemperature[8] + dispTemperature[9]) / 10;
        dtostrf(dispTemp, 4, 1, buf);
        u8g.drawStr( 0, 12, "Temp:");
        u8g.drawStr( 60, 12, buf);
        ltoa(settemperature, buf, 10);
        u8g.drawStr( 0, 26, "Set:");
        u8g.drawStr( 60, 26, buf);
        double dispPower = ((power[0] + power[1] + power[2] + power[3] + power[4]) / 5) * 1.5; //+ power[5] + power[6] + power[7] + power[8] + power[9]) / 10) ;

        u8g.drawLine(108, 0, 108, 64);
        u8g.drawLine(106, 61, 128, 61);

        u8g.drawLine(106, 41, 110, 41);
        u8g.drawLine(106, 21, 110, 21);
        u8g.drawLine(106, 1, 110, 1);

        u8g.drawBox(114, 60 - int(dispPower), 10, int(dispPower) + 1);

        if (sleep) {
          u8g.drawStr( 15, 50, "SLEEP...");
        }
        else {
          u8g.drawLine(2, 29, 2, 63);
          u8g.drawLine(0, 61, 90, 61);

          u8g.drawLine(0, 53, 4, 53);
          u8g.drawLine(0, 45, 4, 45);
          u8g.drawLine(0, 37, 4, 37);

          for (int i = 0; i < 39; i++) {
            u8g.drawLine(5 + (i * 2), int(61 - (tempGraph[i] * 0.08)), 7 + (i * 2), int(61 - (tempGraph[i + 1] * 0.08)));
          }
        }

        if(trained){
          u8g.drawLine(123, 0, 127, 0);
          u8g.drawLine(125, 1, 125, 5);
        }

      } while ( u8g.nextPage() );

      break;
    case 2://sleep temp set
      sleeptemperature += (encoderValue - last) * 2;
      last = encoderValue;
      sleeptemperature = constrain(sleeptemperature, 0, settemperature - 10);
      u8g.firstPage();
      do {
        //graphic commands to redraw the complete screen should be placed here
        u8g.setFont(u8g_font_helvB12);
        char buf[100];
        double dispTemp = (dispTemperature[0] + dispTemperature[1] + dispTemperature[2] + dispTemperature[3] + dispTemperature[4] + dispTemperature[5] + dispTemperature[6] + dispTemperature[7] + dispTemperature[8] + dispTemperature[9]) / 10;
        dtostrf(dispTemp, 4, 1, buf);
        u8g.drawStr( 0, 12, "Temp:");
        u8g.drawStr( 60, 12, buf);
        ltoa(sleeptemperature, buf, 10);
        u8g.drawStr( 0, 26, "Sleep:");
        u8g.drawStr( 60, 26, buf);

      } while ( u8g.nextPage() );
      break;
  }
}



//Interrupts:
void zero() {
  counter++;

  if (counter < count) {
    if (temperature <= pottemperature) {
      digitalWrite(A0, HIGH);
    }
    else {
      digitalWrite(A0, LOW);
    }
  }
  else if (counter >= 40 + count) {

    detachInterrupt(1);
    if (trained && fullPower > 0 && !sleep) {
      fullPower--;
      count=40;
      counter=0;
    }
    else {
      temperature = thermocouple.readCelsius() * 1.28;
      if (!isnan(temperature) && temperature < 500)
      {
        for (int i = 9; i > 0; i--) {
          dispTemperature[i] = dispTemperature[i - 1];
        }
        dispTemperature[0] = temperature;

        if (temperature < pottemperature) { // If heat is missing
          double temp = sqrt(pottemperature - temperature) * 9;
          count = temp;
          count = constrain(count, 0, 40);


          if (!trained && count == 40) {
            fullPowerSet++;
          }
          if (!trained && count != 40 && fullPowerSet > 0) {
            trained = true;
            Serial.println(fullPowerSet);
          }
        }
        else {
          count = 0;
        }
        counter = 0;
      }
      else {
        Serial.print("NAN");
        Serial.println(temperature);
        counter = 0;
        count = 0;
        digitalWrite(A0, LOW);
      }
    }

    for (int i = 4; i > 0; i--) {
      power[i] = power[i - 1];
    }
    power[0] = count;
    attachInterrupt(1, zero, RISING);
  }
  else if (counter >= count) {
    digitalWrite(A0, LOW);
  }
}

void updateEncoder() {
  int MSB = digitalRead(A4); //MSB = most significant bit
  int LSB = digitalRead(A5); //LSB = least significant bit

  int encoded = (MSB << 1) | LSB; //converting the 2 pin value to single number
  int sum  = (lastEncoded << 2) | encoded; //adding it to the previous encoded value

  if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) encoderValue ++;
  if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) encoderValue --;

  lastEncoded = encoded; //store this value for next time
  fullPowerSet = 0;
  trained = false;
}
